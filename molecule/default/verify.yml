---
- name: Verify user_setup role was applied correctly
  hosts: all
  gather_facts: false

  vars_files:
    - ../../vars/molecule_vars.yml

  vars:
    ansible_user: ansible
    ansible_become_password: ansible

  tasks:
    - name: Get passwd for user
      ansible.builtin.getent:
        database: passwd
        key: "{{ item.name }}"
      register: passwd_entry
      loop: "{{ user_setup_users }}"
      when: item.state | default('present') == 'present'

    - name: Assert user was created
      ansible.builtin.assert:
        that:
          - item.item.name in item.ansible_facts.getent_passwd
        fail_msg: "User {{ item.item.name }} was not created"
      loop: "{{ passwd_entry.results }}"
      when: not item.skipped | default(false)

    - name: Assert user has correct shell
      ansible.builtin.assert:
        that:
          - item.ansible_facts.getent_passwd[item.item.name][5] == item.item.shell
        fail_msg: "User {{ item.item.name }} does not have correct shell"
      loop: "{{ passwd_entry.results }}"
      when: not item.skipped | default(false)

    - name: Assert user has correct UID
      ansible.builtin.assert:
        that:
          - item.ansible_facts.getent_passwd[item.item.name][1] | int == item.item.uid | int
        fail_msg: "User {{ item.item.name }} does not have correct UID"
      loop: "{{ passwd_entry.results }}"
      when: not item.skipped | default(false)

    - name: Assert user has correct home directory path in /etc/passwd
      ansible.builtin.assert:
        that:
          - item.ansible_facts.getent_passwd[item.item.name][4] == ('/nonexistent' if not (item.item.create_home | default(true)) else '/home/' + item.item.name)
        fail_msg: "User {{ item.item.name }} does not have correct home directory path in /etc/passwd"
      loop: "{{ passwd_entry.results }}"
      when: not item.skipped | default(false)

    - name: Get group for each user
      ansible.builtin.getent:
        database: group
        key: "{{ item.groups[0] }}"
      register: group_entry
      loop: "{{ user_setup_users }}"
      when: item.state | default('present') == 'present'

    - name: Assert group exists and user is a member
      ansible.builtin.assert:
        that:
          - item.item.groups[0] in item.ansible_facts.getent_group
          - item.item.name in item.ansible_facts.getent_group[item.item.groups[0]][2].split(',')
        fail_msg: "Group {{ item.item.groups[0] }} does not exist or {{ item.item.name }} is not a member"
      loop: "{{ group_entry.results }}"
      when: not item.skipped | default(false)

    - name: Check home directory exists for users with create_home
      ansible.builtin.stat:
        path: "/home/{{ item.name }}"
      register: home_dir_stat
      loop: "{{ user_setup_users }}"
      become: true
      when:
        - item.state | default('present') == 'present'
        - item.create_home | default(true)

    - name: Assert home directory exists for users with create_home
      ansible.builtin.assert:
        that: item.stat.exists
        fail_msg: "Home directory does not exist for user {{ item.item.name }}"
      loop: "{{ home_dir_stat.results }}"
      when: not item.skipped | default(false)

    - name: Check home directory does not exist for users without create_home
      ansible.builtin.stat:
        path: "/home/{{ item.name }}"
      register: no_home_dir_stat
      loop: "{{ user_setup_users }}"
      become: true
      when:
        - item.state | default('present') == 'present'
        - not (item.create_home | default(true))

    - name: Assert home directory does not exist for users without create_home
      ansible.builtin.assert:
        that: not item.stat.exists
        fail_msg: "Home directory should not exist for user {{ item.item.name }}"
      loop: "{{ no_home_dir_stat.results }}"
      when: not item.skipped | default(false)

    - name: Check user directories exist
      ansible.builtin.stat:
        path: "/home/{{ item.0.name }}/{{ item.1.name }}"
      register: dir_checks
      loop: "{{ user_setup_users | selectattr('user_directories', 'defined') | list | subelements('user_directories', skip_missing=True) }}"
      when:
        - item.0.state | default('present') == 'present'
        - item.0.create_home | default(true)
      become: true

    - name: Assert all expected directories exist
      ansible.builtin.assert:
        that: item.stat.exists
        fail_msg: "Directory {{ item.item.1.name }} does not exist for user {{ item.item.0.name }}"
      loop: "{{ dir_checks.results }}"
      when: not item.skipped | default(false)

    - name: Check env file exists for each user
      ansible.builtin.stat:
        path: "/home/{{ item.name }}/{{ item.env_var_file }}"
      register: env_file_stat
      loop: "{{ user_setup_users }}"
      become: true
      when:
        - item.state | default('present') == 'present'
        - item.create_home | default(true)
        - item.env_var_setup | default(false)

    - name: Assert env file exists for each user
      ansible.builtin.assert:
        that: item.stat.exists
        fail_msg: "Env file does not exist for user {{ item.item.name }}"
      loop: "{{ env_file_stat.results }}"
      when: not item.skipped | default(false)

    - name: Check SSH authorized_keys file exists for each user
      ansible.builtin.stat:
        path: "/home/{{ item.name }}/{{ item.ssh_directory }}/authorized_keys"
      register: ssh_stat
      become: true
      loop: "{{ user_setup_users }}"
      when:
        - item.state | default('present') == 'present'
        - item.create_home | default(true)
        - item.ssh_authorized_keys is defined
        - item.ssh_authorized_keys | length > 0

    - name: Assert SSH authorized_keys exists for each user
      ansible.builtin.assert:
        that: item.stat.exists
        fail_msg: "SSH authorized_keys file does not exist for user {{ item.item.name }}"
      loop: "{{ ssh_stat.results }}"
      when: not item.skipped | default(false)

    - name: Read authorized_keys content for each user
      ansible.builtin.slurp:
        path: "/home/{{ item.name }}/{{ item.ssh_directory }}/authorized_keys"
      register: ssh_keys
      become: true
      loop: "{{ user_setup_users }}"
      when:
        - item.state | default('present') == 'present'
        - item.create_home | default(true)
        - item.ssh_authorized_keys is defined
        - item.ssh_authorized_keys | length > 0

    - name: Assert all SSH keys are present
      ansible.builtin.assert:
        that: item.1.key in (item.0.content | b64decode)
        fail_msg: "SSH key not found for user {{ item.0.item.name }}"
      loop: "{{ ssh_keys.results | rejectattr('skipped', 'defined') | list | subelements('item.ssh_authorized_keys') }}"

    - name: Assert SSH keys with options are present in authorized_keys
      ansible.builtin.assert:
        that:
          - item.1.key in (item.0.content | b64decode)
          - item.1.options | replace('\\', '') in (item.0.content | b64decode)
        fail_msg: "SSH key with options not correctly formatted for user {{ item.0.item.name }}"
      loop: "{{ ssh_keys.results | rejectattr('skipped', 'defined') | list | subelements('item.ssh_authorized_keys') }}"
      when: item.1.options is defined

    - name: Assert exclusive mode removes unlisted keys
      ansible.builtin.assert:
        that:
          - (item.content | b64decode).split('\n') | reject('match', '^$') | list | length == item.item.ssh_authorized_keys | length
        fail_msg: "Exclusive mode failed - authorized_keys contains more keys than specified for user {{ item.item.name }}"
      loop: "{{ ssh_keys.results }}"
      when:
        - not item.skipped | default(false)
        - item.item.ssh_authorized_keys_exclusive | default(false)

    - name: Read /etc/shadow entry for each user
      ansible.builtin.command: grep "^{{ item.name }}:" /etc/shadow
      register: shadow_entry
      changed_when: false
      become: true
      loop: "{{ user_setup_users }}"
      when: item.state | default('present') == 'present'

    - name: Assert password is hashed with sha512 for each user
      ansible.builtin.assert:
        that: item.stdout is search("^" ~ item.item.name ~ ":\\$6\\$")
        fail_msg: "Password is not hashed with sha512 for user {{ item.item.name }}"
      loop: "{{ shadow_entry.results }}"
      when: not item.skipped | default(false)

    - name: Check sudoers file exists for users with sudo access
      ansible.builtin.stat:
        path: "/etc/sudoers.d/{{ item.name }}"
      register: sudoers_file
      become: true
      loop: "{{ user_setup_users }}"
      when: item.sudo_access | default(false)

    - name: Assert sudoers file exists for users with sudo
      ansible.builtin.assert:
        that: item.stat.exists
        fail_msg: "Sudoers file does not exist for user {{ item.item.name }}"
      loop: "{{ sudoers_file.results }}"
      when: not item.skipped | default(false)

    - name: Assert sudoers file has correct permissions
      ansible.builtin.assert:
        that:
          - item.stat.mode == '0440'
          - item.stat.pw_name == 'root'
          - item.stat.gr_name == 'root'
        fail_msg: "Sudoers file has incorrect permissions for user {{ item.item.name }}"
      loop: "{{ sudoers_file.results }}"
      when: not item.skipped | default(false)

    - name: Read sudoers file content for users with sudo
      ansible.builtin.slurp:
        path: "/etc/sudoers.d/{{ item.name }}"
      register: sudoers_content
      become: true
      loop: "{{ user_setup_users }}"
      when: item.sudo_access | default(false)

    - name: Assert sudoers file contains NOPASSWD for users with sudo_nopasswd
      ansible.builtin.assert:
        that:
          - (item.content | b64decode) is search(item.item.name ~ ' ALL=\\(ALL\\) NOPASSWD:ALL')
        fail_msg: "Sudoers file does not contain NOPASSWD for user {{ item.item.name }}"
      loop: "{{ sudoers_content.results }}"
      when:
        - not item.skipped | default(false)
        - item.item.sudo_nopasswd | default(false)

    - name: Assert sudoers file does not contain NOPASSWD for users without sudo_nopasswd
      ansible.builtin.assert:
        that:
          - (item.content | b64decode) is search(item.item.name ~ ' ALL=\\(ALL\\) ALL')
          - (item.content | b64decode) is not search('NOPASSWD')
        fail_msg: "Sudoers file incorrectly contains NOPASSWD for user {{ item.item.name }}"
      loop: "{{ sudoers_content.results }}"
      when:
        - not item.skipped | default(false)
        - not (item.item.sudo_nopasswd | default(false))

    - name: Check sudoers file does not exist for users without sudo
      ansible.builtin.stat:
        path: "/etc/sudoers.d/{{ item.name }}"
      register: no_sudoers_file
      become: true
      loop: "{{ user_setup_users }}"
      when: not (item.sudo_access | default(false))

    - name: Assert sudoers file does not exist for users without sudo
      ansible.builtin.assert:
        that: not item.stat.exists
        fail_msg: "Sudoers file should not exist for user {{ item.item.name }}"
      loop: "{{ no_sudoers_file.results }}"
      when: not item.skipped | default(false)

    - name: Assert absent users do not exist
      ansible.builtin.command: id {{ item.name }}
      register: absent_user_check
      failed_when: absent_user_check.rc == 0
      changed_when: false
      loop: "{{ user_setup_users }}"
      when: item.state | default('present') == 'absent'

    - name: Assert home directories do not exist for absent users
      ansible.builtin.stat:
        path: "/home/{{ item.name }}"
      register: absent_user_home
      become: true
      loop: "{{ user_setup_users }}"
      when: item.state | default('present') == 'absent'

    - name: Assert home directory was removed for absent users
      ansible.builtin.assert:
        that: not item.stat.exists
        fail_msg: "Home directory still exists for removed user {{ item.item.name }}"
      loop: "{{ absent_user_home.results }}"
      when: not item.skipped | default(false)

    - name: Assert sudoers files do not exist for absent users
      ansible.builtin.stat:
        path: "/etc/sudoers.d/{{ item.name }}"
      register: absent_user_sudoers
      become: true
      loop: "{{ user_setup_users }}"
      when: item.state | default('present') == 'absent'

    - name: Assert sudoers file was removed for absent users
      ansible.builtin.assert:
        that: not item.stat.exists
        fail_msg: "Sudoers file still exists for removed user {{ item.item.name }}"
      loop: "{{ absent_user_sudoers.results }}"
      when: not item.skipped | default(false)

    - name: Assert absent groups do not exist
      ansible.builtin.getent:
        database: group
        key: "{{ item.name }}"
      register: absent_group_check
      failed_when: false
      loop: "{{ user_setup_groups }}"
      when: item.state | default('present') == 'absent'

    - name: Assert group was removed
      ansible.builtin.assert:
        that: item.ansible_facts is not defined
        fail_msg: "Group {{ item.item.name }} still exists but should be absent"
      loop: "{{ absent_group_check.results }}"
      when: not item.skipped | default(false)
